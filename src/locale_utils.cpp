#include <ali/locale_utils.hpp>
#include <ali/disk_utils.hpp> // for RootMnt
#include <ali/commands.hpp>
#include <QDebug>
#include <fstream>


static const char LocaleGenIntro[] = R"(# Configuration file for locale-gen
#
# lists of locales that are to be generated by the locale-gen command.
#
# Each line is of the form:
#
#     <locale> <charset>
#
#  where <locale> is one of the locales given in /usr/share/i18n/locales
#  and <charset> is one of the character sets listed in /usr/share/i18n/charmaps
#
#  The locale-gen command will generate all the locales,
#  placing them in /usr/lib/locale.
#
#  A list of supported locales is given in /usr/share/i18n/SUPPORTED
#  and is included in this file. Uncomment the needed locales below.
#)";


// these paths use RootMnt (/mnt) because they are used outside of chroot, with
// std::filesystem and std::fstream functions
static const fs::path LiveLocaleGenPath {"/usr/share/i18n/SUPPORTED"};
static const fs::path InstalledLocaleGenPath {RootMnt / "etc/locale.gen"};
static const fs::path InstalledLocaleConfPath {RootMnt / "etc/locale.conf"};
static const fs::path TimezonePath {"/etc/localtime"};

QStringList LocaleUtils::m_locales;
QStringList LocaleUtils::m_timezones;
QStringList LocaleUtils::m_keymaps;


bool LocaleUtils::read_locales()
{
  m_locales.clear();
  m_locales.reserve(500);

  if (!fs::exists(LiveLocaleGenPath))
  {
    qCritical() << "File " << LiveLocaleGenPath.string() << " does not exist";
    return false;
  }

  try
  {    
    char buff[4096] = {'\0'};
    std::ifstream stream{LiveLocaleGenPath};
    
    while (stream.getline(buff, sizeof(buff)).good())
    {
      //format: "<locale> <charset>"
      auto is_utf8 = [](const std::string_view line) -> std::pair<bool, std::string_view>
      {
        if (const auto locale_end = line.find(' '); locale_end != std::string_view::npos && locale_end+1 < line.size())
        {
          if (std::string_view{line.substr(locale_end+1)} == "UTF-8")
            return {true, line.substr(0, locale_end)};
        }

        return {false, std::string_view{}};
      };
      
      if (const auto [store, locale_name] = is_utf8(buff); store)
      {
        m_locales.emplace_back(QString::fromLocal8Bit(locale_name.data(), locale_name.size()));
      }
    }
  }
  catch(const std::exception& e)
  {
    qCritical() << e.what();
  }

  return !m_locales.empty(); 
}


bool LocaleUtils::read_timezones()
{
  // store in list, to retain order, and we can later use the '/'
  // token in the name as a path when we create the sym link with `ln`
  TimezoneList cmd;
  m_timezones = cmd.get_zones();
  return !m_timezones.empty();
}


bool LocaleUtils::read_keymaps()
{
  KeyMaps cmd; 
  m_keymaps = cmd.get_list();
  return !m_keymaps.empty();
}


bool LocaleUtils::generate_locale(const QStringList& user_locales, const QString& current)
{
  bool ok {false};

  if (write_locale_gen(user_locales))
  {
    if (ChRootCmd cmd_gen{std::format("locale-gen")}; cmd_gen.execute() == CmdSuccess)
    {
      const auto cmd_string = std::format("localectl set-locale {}", current.toStdString());

      qDebug() << cmd_string;
      
      try
      {
        std::ofstream stream{InstalledLocaleConfPath, std::ios_base::out | std::ios_base::trunc};
        stream << "LANG=" << current.toStdString() << '\n';
        
        ChRootCmd set_locale{cmd_string};
        ok = set_locale.execute() == CmdSuccess && stream.good();
      }
      catch(const std::exception& e)
      {
        qCritical() << e.what();
      }
    }
  }

  return ok;
}


bool LocaleUtils::write_locale_gen(const QStringList& user_locales)
{
  // write out the intro section from the ISO file,
  // the locales selected, then the original commented locales

  bool set{true};
  try
  {
    std::ofstream stream{InstalledLocaleGenPath, std::ios_base::out | std::ios_base::trunc};
    stream << LocaleGenIntro << '\n';
    
    for (const auto& l : user_locales)
      stream << l.toStdString() << " UTF-8" << '\n';

    stream << '\n';

    for (const auto& l : m_locales)
      stream << '#' << l.toStdString() << '\n';
  }
  catch(const std::exception& e)
  {
    qCritical() << e.what() ;
    set = false;
  }

  return set;
}


bool LocaleUtils::generate_keymap(const std::string& keys, const bool gen_x11_keymap)
{
  static const std::string_view XKBConf = "00-keyboard.conf";
  static const fs::path LiveX11KeyboardConfDir = "etc/X11/xorg.conf.d";

  static const fs::path LiveX11KeyboardConfPath {"/" / LiveX11KeyboardConfDir / XKBConf};
  static const fs::path InstalledX11KeyboardConfPath {RootMnt / LiveX11KeyboardConfDir / XKBConf};

  static const fs::path LiveVirtualConsolePath {"/etc/vconsole.conf"};
  static const fs::path InstalledVirtualConsolePath {RootMnt / "etc/vconsole.conf"};

  // arguably a bit hacky: we can't use `localectl set-keymap` in chroot
  // because there is not a proper/full dbus running. So instead
  // we run the command within the live system, then copy the files to the
  // installed system. Therefore this should be run after the desktop profile

  bool set{false};

  try
  {
    Command set_keymap {std::format("localectl set-keymap {}", keys)};
    if (set_keymap.execute() == CmdSuccess)
    {
      std::error_code ec_x11, ec_vconsole;

      fs::copy_file(LiveVirtualConsolePath, InstalledVirtualConsolePath, fs::copy_options::overwrite_existing, ec_vconsole);

      if (gen_x11_keymap)
      {
        fs::create_directories(InstalledX11KeyboardConfPath.parent_path());
        fs::copy_file(LiveX11KeyboardConfPath, InstalledX11KeyboardConfPath, fs::copy_options::overwrite_existing, ec_x11);
      }

      set = ec_x11.value() == 0 && ec_vconsole.value() == 0;
    }
  }
  catch(const std::exception& e)
  {
    qCritical() << e.what() ;      
  }
  return set;
}


bool LocaleUtils::generate_timezone(const std::string& zone)
{
  ChRootCmd set_cmd{std::format("ln -sf /usr/share/zoneinfo/{} {}", zone, TimezonePath.string())};
  if (set_cmd.execute() == CmdSuccess)
  {
    ChRootCmd set_hw_clock{"hwclock --systohc"};
    return set_hw_clock.execute() == CmdSuccess;
  }

  return false;
}