#include <ali/locale_utils.hpp>
#include <ali/disk_utils.hpp> // for RootMnt
#include <ali/commands.hpp>
#include <QDebug>
#include <fstream>


static const char LocaleGenIntro[] = R"(# Configuration file for locale-gen
#
# lists of locales that are to be generated by the locale-gen command.
#
# Each line is of the form:
#
#     <locale> <charset>
#
#  where <locale> is one of the locales given in /usr/share/i18n/locales
#  and <charset> is one of the character sets listed in /usr/share/i18n/charmaps
#
#  The locale-gen command will generate all the locales,
#  placing them in /usr/lib/locale.
#
#  A list of supported locales is given in /usr/share/i18n/SUPPORTED
#  and is included in this file. Uncomment the needed locales below.
#)";


// these paths use RootMnt (/mnt) because they are used outside of chroot, with
// std::filesystem and std::fstream functions
static const fs::path LiveLocaleGenPath {"/etc/locale.gen"};
static const fs::path InstalledLocaleGenPath {RootMnt / "etc/locale.gen"};
static const fs::path InstalledLocaleConfPath {RootMnt / "etc/locale.conf"};
static const fs::path InstalledVirtualConsolePath {RootMnt / "etc/vconsole.conf"};
static const fs::path TimezonePath {"/etc/localtime"};

//std::string LocaleUtils::m_intro;
QStringList LocaleUtils::m_locales;
QStringList LocaleUtils::m_timezones;
QStringList LocaleUtils::m_keymaps;


bool LocaleUtils::read_locales()
{
  m_locales.clear();
  m_locales.reserve(500);


  //
  // READ /usr/share/i18n/SUPPORTED instead, avoids dealing with the introductory waffle
  //      when writing, search each line for the locale, and uncommenting
  //
  if (!fs::exists(LiveLocaleGenPath))
  {
    qCritical() << "File " << LiveLocaleGenPath.string() << " does not exist";
    return false;
  }

  try
  {
    char buff[4096] = {'\0'};
    std::ifstream stream{LiveLocaleGenPath};
    
    while (stream.getline(buff, sizeof(buff)).good())
    {
      const bool is_entry = (buff[0] == '#' && isalpha(buff[1])) || isalpha(buff[0]);

      if (is_entry)
      {
        //format: "#<locale> <charset>  "
        auto is_utf8 = [](const std::string_view line) -> std::pair<bool, QString>
        {
          std::stringstream ss;
          ss << std::noskipws << line;

          std::string locale, charset;
          getline(ss, locale, ' ');
          getline(ss, charset, ' ');

          if (!locale.empty() && charset == "UTF-8")
            return {true, QString::fromStdString(locale)};
          else
            return {false, QString{}};
        };
        
        if (const auto [store, locale_name] = is_utf8(buff[0] == '#' ? buff+1 : buff); store)
        {
          m_locales.emplace_back(locale_name);
        }
      }
    }
  }
  catch(const std::exception& e)
  {
    qCritical() << e.what();
  }

  return !m_locales.empty(); 
}


bool LocaleUtils::read_timezones()
{
  // store in list, to retain order, and we can later use the '/'
  // token in the name as a path when we create the sym link with `ln`
  TimezoneList cmd;
  m_timezones = cmd.get_zones();
  return !m_timezones.empty();
}


bool LocaleUtils::read_keymaps()
{
  KeyMaps cmd; 
  m_keymaps = cmd.get_list();
  return !m_keymaps.empty();
}


bool LocaleUtils::generate_locale(const QStringList& user_locales, const QString& current)
{
  bool ok {false};

  if (write_locale_gen(user_locales))
  {
    if (ChRootCmd cmd_gen{std::format("locale-gen")}; cmd_gen.execute() == CmdSuccess)
    {
      const auto cmd_string = std::format("localectl set-locale {}", current.toStdString());

      qDebug() << cmd_string;
      
      try
      {
        std::ofstream stream{InstalledLocaleConfPath, std::ios_base::out | std::ios_base::trunc};
        stream << "LANG=" << current.toStdString() << '\n';
        
        ChRootCmd set_locale{cmd_string};
        ok = set_locale.execute() == CmdSuccess && stream.good();
      }
      catch(const std::exception& e)
      {
        qCritical() << e.what();
      }
    }
  }

  return ok;
}


bool LocaleUtils::write_locale_gen(const QStringList& user_locales)
{
  // write out the intro section from the ISO file,
  // the locales selected, then the original commented locales

  bool set{true};
  try
  {
    std::ofstream stream{InstalledLocaleGenPath, std::ios_base::out | std::ios_base::trunc};
    stream << LocaleGenIntro << '\n';
    
    for (const auto& l : user_locales)
      stream << l.toStdString() << " UTF-8" << '\n';

    stream << '\n';

    for (const auto& l : m_locales)
      stream << '#' << l.toStdString() << '\n';
  }
  catch(const std::exception& e)
  {
    qCritical() << e.what() ;
    set = false;
  }

  return set;
}


bool LocaleUtils::generate_keymap(const std::string& keys)
{
  bool set{false};

  try
  {
    ChRootCmd set_keys{std::format("localectl set-keymap {}", keys)};
    //ChRootCmd set_x11_keys{std::format("localectl set-x11-keymap {}", keys)};
    ChRootCmd load_cmd{std::format("loadkeys {}", keys)};

    set = set_keys.execute() == CmdSuccess &&
          //  set_x11_keys.execute() == CmdSuccess &&
          load_cmd.execute() == CmdSuccess;
    
    std::ofstream stream{InstalledVirtualConsolePath, std::ios_base::out | std::ios_base::trunc};
    stream << "KEYMAP=" << keys << '\n';
  }
  catch(const std::exception& e)
  {
    qCritical() << e.what() ;      
  }
  return set;
}


bool LocaleUtils::generate_timezone(const std::string& zone)
{
  ChRootCmd set_cmd{std::format("ln -sf /usr/share/zoneinfo/{} {}", zone, TimezonePath.string())};
  if (set_cmd.execute() == CmdSuccess)
  {
    ChRootCmd set_hw_clock{"hwclock --systohc"};
    return set_hw_clock.execute() == CmdSuccess;
  }

  return false;
}